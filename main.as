package{	import flash.display.Bitmap;	import flash.display.BlendMode;	import flash.display.GradientType;	import flash.display.Shape;	import flash.display.SpreadMethod;	import flash.display.Sprite;	import flash.events.Event;	import flash.events.KeyboardEvent;	import flash.events.MouseEvent;	import flash.events.TimerEvent;	import flash.filters.BlurFilter;	import flash.filters.GlowFilter;	import flash.geom.ColorTransform;	import flash.geom.Matrix;	import flash.geom.Point;	import flash.text.TextField;	import flash.text.TextFormat;	import flash.ui.Keyboard;	import flash.ui.Mouse;	import flash.utils.Timer;	public class main extends Sprite	{		private static var _instance: main;				/**		 * Original image from: getimagefree.com		 */		[Embed(source="img/bgfree.jpg")] 		private static var bg: Class;				private static const LEFT: String = 'left';		private static const RIGHT: String = 'right';		private static const UP: String = 'up';		private static const DOWN: String = 'down';				private static var speedMax: Number = 15.00;		private static var speedAccel: Number = 0.15;		private static var speedDecay: Number = 0.995;		private static var speedUPDecay: Number = 0.980;		private static var gravity: Number = 2.5;				private var aNum: uint = 20; 		private var aMaxSize: uint = 25; 		private var respawnCnt: uint = 2;				private var _life: int = 3 * 100; 		public function set shields( v: Number ): void		{			if ( _life > 0 )				_life *= v;		}				public var tf: TextField;		public var tfC: Sprite;				private var degrees: Number;		private var colided: Boolean;		private static var asteroids: Vector.<Asteroid>;		private static var mrC: Sprite;		private var mrCFilters: Vector.<GlowFilter>;		private var mrCCT: Vector.<ColorTransform>;		private var gameTitle: TextField;				private var colliders: Object;		private var _colliders: Vector.<Asteroid>;				private var lastShot: Timer;		private var respawn: Boolean = false;				private var _p: Point;		public function get p(): Point		{			return _p;		}				private var t: Timer;				private var tz: Shape;		private static var moving: Object;		private static var _speed: Object;		public var aLen: uint;		public static var aCount: uint;		private var canvas: Shape;		public var mCursor: Shape;				private var _shotYield: Number = 10.0;		public function set shotYield( v: uint ): void		{			if ( _shotYield > 0 )				_shotYield -= v;		}		public function get shotYield(): uint		{			if ( int( _shotYield + 0.07 + 0.5 ) <= 10.0 )				_shotYield += 0.07;			return _shotYield;		}				public static function get getAsteroids(): Vector.<Asteroid>		{			return asteroids;		}				public static function get player(): Sprite		{			return mrC;		}				public static function get instance(): main		{			return _instance;		}				private static function speed( n: String ): Number		{			if ( moving[ n ] && _speed[ n ] < speedMax )				_speed[ n ] += speedAccel;			else if ( !moving[ n ] && _speed[ n ] > 0.0 )				_speed[ n ] *= ( n == UP ) ? speedUPDecay : speedDecay;			return _speed[ n ];		}				/**		 * CONSTRUCTOR		 */		function main()		{			// VAR INIT			Missile.ammo = Missile.AMMO;			_instance = this;			asteroids = new Vector.<Asteroid>;			tf = new TextField();			tfC = new Sprite();			mrC = new Sprite();			_p = new Point( mrC.x, mrC.y );			mrCFilters = new Vector.<GlowFilter>;			mrCCT = new Vector.<ColorTransform>;			gameTitle = new TextField();			canvas = new Shape();			mCursor = new Shape();			tz = new Shape();			colided = false;			moving = { left: false, right: false, up: false, down: false, m: false };			_speed = { left: 0.0, right: 0.0, up: 0.0, down: 0.0 };			colliders = {};						// FILTERS			mrCFilters.push( new GlowFilter( 0xAAAAFF, 0.8, 25, 25 ) );			mrCFilters.push( new GlowFilter( 0x000000, 0.5, 10, 10 ) );						// TRANSFORMS			mrCCT.push( new ColorTransform( 0.5, 1.5, 3 ) );			mrCCT.push( new ColorTransform( 1, 1, 1 ) );						// BG IMAGE			addChild( new bg() );						addEventListener( Event.ADDED_TO_STAGE, addedToStageHandler, false, 0, true  );			addEventListener( Event.REMOVED_FROM_STAGE, removedFromStageHandler, false, 0, true );		}				private function addedToStageHandler( e: Event ): void		{			addEventListener( Event.ADDED_TO_STAGE, addedToStageHandler );						// SMOKE INIT			Smoke.init( 200 );						// GAME RESTART LINK 			tfC.addEventListener( MouseEvent.CLICK, function( e: MouseEvent ): void {				nanoPHAGE.respawn();			});			// MOUSE			Mouse.hide();			mCursor.graphics.lineStyle( 2, 0xFFFF00 );			mCursor.graphics.moveTo( 0, 5 );			mCursor.graphics.lineTo( 10, 5 );			mCursor.graphics.moveTo( 5, 0 );			mCursor.graphics.lineTo( 5, 10 );			addChild( mCursor );						// MAIN STAGE			graphics.beginFill( 0x000000, 0.3 );			graphics.drawRect( 0, 0, nanoPHAGE.w, nanoPHAGE.h );			graphics.endFill();						// ELECTRICITY CANVAS			canvas.graphics.drawRect( 0, 0, nanoPHAGE.w, nanoPHAGE.h );			addChild( canvas );						// PLAYER			var matr: Matrix = new Matrix();			matr.createGradientBox( 50, 50, 0, -25, -25 );			var spreadMethod: String = SpreadMethod.PAD			mrC.graphics.beginGradientFill( 				GradientType.RADIAL, [ 0x999999 , 0x333333 ], 				[ 1.0, 1.0 ], [ 150, 255 ],				matr, SpreadMethod.PAD			);            mrC.graphics.lineStyle( 1, 0x333333 );			mrC.graphics.drawCircle( 0, 0, 25 );			mrC.graphics.endFill();			addChild( mrC );			mrC.x = 30; // width / 2 - 25;			mrC.y = 30; // height / 2 - 25;			mrC.filters = [ new GlowFilter( 0x000000, 0.5, 10, 10 ) ];						// PLAYER'S CANNON 			tz.graphics.lineStyle( 10, 0x00000 );			tz.graphics.moveTo( 0, 0 );			tz.graphics.lineTo( 0, 35 );			tz.x = 0;			tz.y = 0;			mrC.addChild( tz );						// EVENTS			main.instance.addEventListener( MouseEvent.CLICK, clickHandler, false, 0, true );			main.instance.addEventListener( MouseEvent.MOUSE_DOWN, mouseDownHandler, false, 0, true );			main.instance.addEventListener( MouseEvent.MOUSE_UP, mouseUpHandler, false, 0, true );			stage.addEventListener( KeyboardEvent.KEY_DOWN, keyDownHandler, false, 0, true );			stage.addEventListener( KeyboardEvent.KEY_UP, keyUpHandler, false, 0, true );			addEventListener( Event.ENTER_FRAME, onEnterFrameHandler, false, 0, true );						// ASTEROIDS			var tmpA: Asteroid;			while ( aNum-- ) {				tmpA = new Asteroid( 					100 + Math.random() * ( nanoPHAGE.w - 100 ), 					100 + Math.random() * ( nanoPHAGE.h - 100 ), 					( Math.random() + 0.3 ) * aMaxSize, Math.random() * 3 				);				asteroids.push( tmpA );				addChild( tmpA );			}			aLen = asteroids.length;			aCount = aLen;						// ASTEROID RESPAWN SETUP			t = new Timer( 30 * 1000, 1 );			t.start();			t.addEventListener( TimerEvent.TIMER_COMPLETE, respawnAsteroids, false, 0, true );						// SCORE			tf.mouseEnabled = false;			tf.text = '' + ( _life / 3 );			tf.setTextFormat( new TextFormat( 'Arial', 20, 0xFFFF00, true, null ) );			tf.defaultTextFormat = tf.getTextFormat();			tf.autoSize = 'left';			tfC.addChild( tf );			tfC.mouseChildren = false;			tfC.mouseEnabled = false;			tfC.x = 10;			tfC.y = 5;			addChild( tfC )						// GAME TITLE			gameTitle.text = 'nanoPHAGE '+ nanoPHAGE.VERSION;			gameTitle.mouseEnabled = false;			gameTitle.setTextFormat( new TextFormat( 'Arial', 20, 0x00FFFF, true, null ) );			gameTitle.defaultTextFormat = tf.getTextFormat();			gameTitle.x = nanoPHAGE.w - 255;			gameTitle.y = nanoPHAGE.h - 30;			gameTitle.width = 250;			//addChild( gameTitle );		}				private function respawnAsteroids( e: TimerEvent ): void		{			respawn = true;			t.start();		}						private function removedFromStageHandler( e: Event ): void		{			removeEventListener( Event.REMOVED_FROM_STAGE, removedFromStageHandler );			removeEventListener( Event.ENTER_FRAME, onEnterFrameHandler );			main.instance.removeEventListener( MouseEvent.CLICK, clickHandler );			main.instance.removeEventListener( MouseEvent.MOUSE_DOWN, mouseDownHandler );			main.instance.removeEventListener( MouseEvent.MOUSE_UP, mouseUpHandler );			stage.removeEventListener( KeyboardEvent.KEY_DOWN, keyDownHandler );			stage.removeEventListener( KeyboardEvent.KEY_UP, keyUpHandler );		}				private function clickHandler( e: MouseEvent ): void		{			if ( !colided && _life != 0 && _shotYield > 0 ) {				shotYield = 1;				var projectile: Projectile = new Projectile();				addChild( projectile );			}		}				private function mouseDownHandler( e: MouseEvent ): void		{			if ( e.buttonDown ) {				shoot();				}		}				private function mouseUpHandler( e: MouseEvent ): void		{			lastShot.stop();		}				private function shoot(): void		{				lastShot = new Timer( 200, 1 );			lastShot.start();			if ( !colided )				lastShot.addEventListener( TimerEvent.TIMER_COMPLETE, function ( e: TimerEvent ): void {					if ( _shotYield > 0 ) {						shotYield = 1;						var projectile: Projectile = new Projectile();						addChild( projectile );					}								shoot();				} );		}				private function onEnterFrameHandler( e: Event ): void		{			// RESPAWN ASTEROIDS			if ( respawn ) {				var tmpA: Asteroid;				for ( var k: uint = 0; k < respawnCnt; k++ ) {					tmpA = new Asteroid( NaN, NaN, ( Math.random() + 0.3 ) * 30, Math.random() * 3 );					asteroids.push( tmpA );					addChild( tmpA );					aCount++;				}				respawnCnt++;				respawn = false;				aLen = asteroids.length;			}						// PLAYER COORDINATES			_p.x = mrC.x;			_p.y = mrC.y;						// MOUSE			mCursor.x = main.instance.mouseX;			mCursor.y = main.instance.mouseY;			// ELECTRICITY && COLLISIONS			canvas.graphics.clear();			canvas.graphics.lineStyle( 3, 0x66AA00, 1.0 );						var c: uint = 0;			var j: uint;			var aJ: Asteroid;			var i: uint;			var aI: Asteroid;			var pD: Number;			var pR: Number;			var pEX: Number;			var inx: Boolean;			var col: Boolean;			var curveT: Number;			var blasted: Vector.<Asteroid> = new Vector.<Asteroid>;						for ( j = 0; j < aLen; j++ ) {				aJ = asteroids[ j ] as Asteroid;								if ( aJ.dead || aJ.dead && !Asteroid.rocketed ) continue;				if ( aJ.unTouchable > 0 ) {  //trace( aJ );					aJ.unTouchable--;					continue;				}								if ( Asteroid.rocketed && aJ != Asteroid.rocketed ) {					pEX = Point.distance( Asteroid.rocketed.p, aJ.p );					if ( pEX < 100 )						blasted.push( aJ );				}					for ( i = j + 1; i < aLen; i++ ) {					aI = asteroids[ i ] as Asteroid;										if ( aI.dead ) continue;					if ( aI.unTouchable > 0 ) {						aI.unTouchable--;						continue;					}					if ( aI.x < aJ.x - 80.0 || aI.x > aJ.x + 80.0 ) continue;					if ( aI.y < aJ.y - 80.0 || aI.y > aJ.y + 80.0 ) continue;										pD = Point.distance( aJ.p, aI.p );					pR = aJ.r + aI.r;					c++;					if ( pD > pR + 70.0 ) continue;									col = pD <= pR;										if ( pD > pR + 5 ) {						canvas.graphics.moveTo( aJ.p.x, aJ.p.y );						curveT = -30 + ( Math.random() * 60 );						canvas.graphics.curveTo( curveT + aI.p.x, curveT + aI.p.y, aI.p.x, aI.p.y );					}										inx = colliders[ aI.name + aJ.name ] || colliders[ aI.name + aJ.name ] ? true : false;										if ( col && !inx ) { 						aI.cRot = aJ.rott;						aJ.cRot = aI.rott;						aI.coll();						aJ.coll();						colliders[ aI.name + aJ.name ] = true;					} 					if ( !col && inx ) {						delete colliders[ aI.name + aJ.name ];						delete colliders[ aJ.name + aI.name ];					}				}			}			if ( Asteroid.rocketed ) {				var dy: Number;				var dx: Number;								for each ( var aS: Asteroid in blasted ) {					if ( aS.dead ) continue;										aS.damage = 10;										var aBR: Number = Math.atan2( Explosion.p.y - aS.p.y, Explosion.p.x - aS.p.x ) * 180 / Math.PI;										aS.ratioX = Math.sin( aBR * Math.PI / 180 );					aS.ratioY = Math.cos( aBR * Math.PI / 180 );					aS.setSpeed = Asteroid.speedMax * 2;					aS.unTouchable = Asteroid.UNTOUCH;				}				aBR = Math.atan2( Explosion.p.y - Asteroid.rocketed.p.y, Explosion.p.x - Asteroid.rocketed.p.x ) * 180 / Math.PI;				Asteroid.rocketed.ratioX = Math.sin( aBR * Math.PI / 180 );				Asteroid.rocketed.ratioY = Math.cos( aBR * Math.PI / 180 );				Asteroid.rocketed.setSpeed = Asteroid.speedMax * 2;				Asteroid.rocketed.unTouchable = Asteroid.UNTOUCH;			}			Asteroid.rocketed = null;			//trace( c.toString() );			// WIN or FAIL			if ( ( aCount == 0 || _life == 0 ) && !tfC.mouseEnabled ) {								main.instance.removeEventListener( MouseEvent.CLICK, clickHandler );				t.removeEventListener( TimerEvent.TIMER_COMPLETE, respawnAsteroids );				t.stop();				setChildIndex( tfC, numChildren - 1 );				tfC.x = nanoPHAGE.w / 2 - tfC.width / 2 + 60;				tfC.y = nanoPHAGE.h / 2 - tfC.height / 2;				tf.text = aCount == 0 ? 'Epic WIN! Click to restart.' : 'Epic FAIL! Click to restart.';				tfC.mouseEnabled = true;				tf.setTextFormat( new TextFormat( 'Arial', 30, 0xFFFF00, true, null ) );					if ( _life == 0 ) {					mrC.transform.colorTransform = new ColorTransform( 1, 0.2, 0.7 );					mrC.filters = [ new BlurFilter( 7, 7 ) ];				}								main.instance.removeEventListener( KeyboardEvent.KEY_DOWN, keyDownHandler );				main.instance.removeEventListener( KeyboardEvent.KEY_UP, keyUpHandler );							} else if ( !tfC.mouseEnabled ) {								// SCOREBOARD				tf.htmlText = 'Shields [ <font color="#ffffff">' + String( int( _life / 3 + 0.5 ) ) + '/100</font> ]'				+ ', Enemies [ <font color="#ffffff">' + aCount.toString() + '</font> ]'				+ ', Ammo [ <font color="#ffffff">' + shotYield.toString() + '/10</font> ]'				+ ', Rockets [ <font color="#ffffff">' + Missile.ammo.toString() + '</font> ]';								var dp: Number = mrC.width * 0.5 + 5;				if ( mrC.x - dp > nanoPHAGE.w )					mrC.x = 0 - dp;				if ( mrC.y - dp > nanoPHAGE.h )					mrC.y = 0 - dp;									if ( mrC.x < 0 - dp )					mrC.x = nanoPHAGE.w + dp;				if ( mrC.y < 0 - dp )					mrC.y = nanoPHAGE.h + dp;								// CANNON				this.degrees = Math.atan2( main.instance.mouseY - mrC.y, main.instance.mouseX - mrC.x ) * 180 / Math.PI - 90;								this.colided = hasColided();				if ( this.colided ) {										// DAMAGE					shields = 0.999;										mrC.filters = [ mrCFilters[ 0 ] ];					mrC.blendMode = BlendMode.LAYER;					mrC.transform.colorTransform = mrCCT[ 0 ];										speedMax = 2.0;				} else {					mrC.filters = [ mrCFilters[ 1 ] ];					mrC.blendMode = BlendMode.NORMAL;					mrC.transform.colorTransform = mrCCT[ 1 ];										speedMax = 15.0;										tz.rotation += ( 180 / Math.PI ) * Math.atan2( 						( 							Math.cos( tz.rotation * Math.PI / 180 ) * Math.sin( degrees * Math.PI / 180 ) 							- Math.sin( tz.rotation * Math.PI / 180 ) * Math.cos( degrees * Math.PI / 180 )						), (							Math.sin( tz.rotation * Math.PI / 180 ) * Math.sin( degrees * Math.PI / 180 ) 							+ Math.cos( tz.rotation * Math.PI / 180 ) * Math.cos( degrees * Math.PI / 180 ) 						)					) / 15;				}			}						// PLAYER MOVEMENT			mrC.x += speed( RIGHT );			mrC.x -= speed( LEFT ); 			mrC.y -= speed( UP );			mrC.y += speed( DOWN );						// GRAVITY			mrC.y += gravity;		}				private function hasColided(): Boolean		{			var col: Boolean = false;			for each ( var aS: Asteroid in asteroids ) {				if ( !aS.dead && Point.distance( _p, aS.p ) <= mrC.width * 0.5 + aS.r ) {					aS.colidedMain = true;					col = true;				} else {					aS.colidedMain = false;				}			}			return col;		}		private function keyDownHandler( e: KeyboardEvent ): void		{				switch( e.keyCode )			{				case Keyboard.UP:				case 87: // W					moving.up = true;					break;									case Keyboard.DOWN:				case 83: // S					moving.down = true;					break;									case Keyboard.LEFT:				case 65: // A					moving.left = true;					break;									case Keyboard.RIGHT:				case 68: // D					moving.right = true;					break;									case Keyboard.CONTROL:				case Keyboard.SPACE:					if ( !colided && !Missile.active ) {						var missile: Missile = new Missile();						addChildAt( missile, 1 );					}			}		}				private function keyUpHandler( e: KeyboardEvent ): void		{			switch( e.keyCode )			{				case Keyboard.UP:				case 87: // W					moving.up = false;					break;									case Keyboard.DOWN:				case 83: // S					moving.down = false;					break;									case Keyboard.LEFT:				case 65: // A					moving.left = false;					break;									case Keyboard.RIGHT:				case 68: // D					moving.right = false;					break;			}		}	}}